import { NextRequest, NextResponse } from 'next/server'
import { TRANSLATION_CHUNK_CONFIG, getOptimalChunkSize, estimateChunkCount, estimateProcessingTime } from '@/lib/config/translation'
import { createServerCreditService } from '@/lib/services/credits'

// ç¿»è¯‘é˜Ÿåˆ—é…ç½®
// ä½¿ç”¨å…¨å±€ç¿»è¯‘é…ç½®
const CONFIG = TRANSLATION_CHUNK_CONFIG;

// åŠ¨æ€å¯¼å…¥ Supabase å®¢æˆ·ç«¯
const createSupabaseAdminClient = () => {
  const { createClient } = require('@supabase/supabase-js')
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    }
  )
}

// è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
async function getOptionalUser(request: NextRequest) {
  try {
    console.log('[Queue Auth Debug] å¼€å§‹ç”¨æˆ·è®¤è¯æ£€æŸ¥');
    
    const authHeader = request.headers.get('authorization');
    console.log('[Queue Auth Debug] Authorization header:', authHeader ? 'Present' : 'Missing');
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      console.log('[Queue Auth Debug] æ— æ•ˆçš„è®¤è¯å¤´æ ¼å¼');
      return null;
    }

    const token = authHeader.substring(7);
    console.log('[Queue Auth Debug] Token length:', token.length);
    console.log('[Queue Auth Debug] Token preview:', token.substring(0, 20) + '...');
    
    const { createClient } = require('@supabase/supabase-js');
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );

    console.log('[Queue Auth Debug] Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);
    console.log('[Queue Auth Debug] Supabase Key present:', !!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);

    const { data: { user }, error } = await supabase.auth.getUser(token);
    
    if (error) {
      console.log('[Queue Auth Debug] Supabase auth error:', error.message);
      return null;
    }
    
    if (user) {
      console.log('[Queue Auth Debug] ç”¨æˆ·è®¤è¯æˆåŠŸ:', user.id, user.email);
      return user;
    } else {
      console.log('[Queue Auth Debug] ç”¨æˆ·è®¤è¯å¤±è´¥: æ— ç”¨æˆ·æ•°æ®');
      return null;
    }
  } catch (error) {
    console.log('[Queue Auth Debug] è®¤è¯å¼‚å¸¸:', error);
    return null;
  }
}

// å†…å­˜é˜Ÿåˆ—å­˜å‚¨ (ç”Ÿäº§ç¯å¢ƒå»ºè®®ä½¿ç”¨Redis)
const translationQueue = new Map();

// ä»»åŠ¡æŒä¹…åŒ–åˆ°æ–‡ä»¶ç³»ç»Ÿ (ç®€å•çš„å¤‡ä»½æœºåˆ¶)
const fs = require('fs');
const path = require('path');
const QUEUE_BACKUP_FILE = path.join(process.cwd(), 'temp', 'translation-queue-backup.json');

// ä¿å­˜é˜Ÿåˆ—çŠ¶æ€åˆ°æ–‡ä»¶
function saveQueueToFile() {
  try {
    const queueData = Array.from(translationQueue.entries());
    const backupData = {
      timestamp: new Date().toISOString(),
      jobs: queueData
    };
    
    // ç¡®ä¿tempç›®å½•å­˜åœ¨
    const tempDir = path.dirname(QUEUE_BACKUP_FILE);
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    
    fs.writeFileSync(QUEUE_BACKUP_FILE, JSON.stringify(backupData, null, 2));
    console.log(`[Queue] é˜Ÿåˆ—çŠ¶æ€å·²ä¿å­˜ï¼ŒåŒ…å« ${queueData.length} ä¸ªä»»åŠ¡`);
  } catch (error) {
    console.error('[Queue] ä¿å­˜é˜Ÿåˆ—çŠ¶æ€å¤±è´¥:', error);
  }
}

// ä»æ–‡ä»¶æ¢å¤é˜Ÿåˆ—çŠ¶æ€
function loadQueueFromFile() {
  try {
    if (fs.existsSync(QUEUE_BACKUP_FILE)) {
      const backupData = JSON.parse(fs.readFileSync(QUEUE_BACKUP_FILE, 'utf8'));
      const now = new Date();
      const backupTime = new Date(backupData.timestamp);
      const timeDiff = now.getTime() - backupTime.getTime();
      
      // åªæ¢å¤30åˆ†é’Ÿå†…çš„ä»»åŠ¡ï¼Œé¿å…æ¢å¤è¿‡æœŸä»»åŠ¡
      if (timeDiff < 30 * 60 * 1000) {
        let restoredCount = 0;
        backupData.jobs.forEach(([jobId, job]) => {
          // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å·²ç»å­˜åœ¨ï¼ˆé¿å…è¦†ç›–æ­£åœ¨å¤„ç†çš„ä»»åŠ¡ï¼‰
          if (!translationQueue.has(jobId)) {
            // åªæ¢å¤æœªå®Œæˆçš„ä»»åŠ¡ï¼Œä¸”ä¸æ˜¯å¾ˆä¹…ä¹‹å‰çš„ä»»åŠ¡
            const jobAge = now.getTime() - new Date(job.createdAt).getTime();
            if ((job.status === 'pending' || job.status === 'processing') && jobAge < 30 * 60 * 1000) {
              // é‡ç½®processingçŠ¶æ€ä¸ºpendingï¼Œå› ä¸ºå¤„ç†è¿‡ç¨‹å·²ä¸­æ–­
              if (job.status === 'processing') {
                job.status = 'pending';
                job.progress = 0;
                console.log(`[Queue] é‡ç½®ä¸­æ–­çš„ä»»åŠ¡çŠ¶æ€: ${jobId} processing -> pending`);
              }
              translationQueue.set(jobId, job);
              restoredCount++;
              console.log(`[Queue] æ¢å¤ä»»åŠ¡: ${jobId}, çŠ¶æ€: ${job.status}`);
            }
          } else {
            console.log(`[Queue] è·³è¿‡å·²å­˜åœ¨çš„ä»»åŠ¡: ${jobId}`);
          }
        });
        console.log(`[Queue] ä»å¤‡ä»½æ¢å¤äº† ${restoredCount} ä¸ªä»»åŠ¡`);
        
        // å¦‚æœæœ‰æ¢å¤çš„ä»»åŠ¡ï¼Œå¯åŠ¨å¤„ç†å™¨
        if (restoredCount > 0) {
          console.log('[Queue] å¯åŠ¨å¤„ç†å™¨å¤„ç†æ¢å¤çš„ä»»åŠ¡');
          setTimeout(() => {
            processNextPendingJob();
          }, 1000);
        }
      } else {
        console.log('[Queue] å¤‡ä»½æ–‡ä»¶è¿‡æœŸï¼Œä¸è¿›è¡Œæ¢å¤');
        // åˆ é™¤è¿‡æœŸçš„å¤‡ä»½æ–‡ä»¶
        fs.unlinkSync(QUEUE_BACKUP_FILE);
      }
    }
  } catch (error) {
    console.error('[Queue] æ¢å¤é˜Ÿåˆ—çŠ¶æ€å¤±è´¥:', error);
  }
}

// å¯åŠ¨æ—¶æ¢å¤é˜Ÿåˆ—
loadQueueFromFile();

interface QueueJob {
  id: string;
  text: string;
  sourceLanguage: string;
  targetLanguage: string;
  chunks: string[];
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  result?: string;
  error?: string;
  createdAt: Date;
  updatedAt: Date;
}

// åˆ›å»ºç¿»è¯‘ä»»åŠ¡
export async function POST(request: NextRequest) {
  try {
    const { text, sourceLanguage, targetLanguage } = await request.json();
    
    if (!text || !sourceLanguage || !targetLanguage) {
      return NextResponse.json({
        error: 'ç¼ºå°‘å¿…è¦å‚æ•°',
        code: 'MISSING_PARAMETERS'
      }, { status: 400 });
    }

    // è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆé˜Ÿåˆ—å¤„ç†éœ€è¦ç”¨æˆ·ç™»å½•ï¼‰
    const user = await getOptionalUser(request);
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç§¯åˆ†ï¼ˆé˜Ÿåˆ—å¤„ç†é€šå¸¸ç”¨äºé•¿æ–‡æœ¬ï¼Œéœ€è¦ç§¯åˆ†ï¼‰
    const FREE_LIMIT = 1000;
    const needsCredits = text.length > FREE_LIMIT && user;
    
    if (text.length > FREE_LIMIT && !user) {
      return NextResponse.json({
        error: 'é•¿æ–‡æœ¬ç¿»è¯‘éœ€è¦ç™»å½•',
        code: 'LOGIN_REQUIRED'
      }, { status: 401 });
    }
    
    if (needsCredits) {
      console.log(`[Queue Translation] é•¿æ–‡æœ¬ç¿»è¯‘éœ€è¦ç§¯åˆ†æ£€æŸ¥: ${text.length}å­—ç¬¦`);
      
      // è®¡ç®—æ‰€éœ€ç§¯åˆ†
      const creditService = createServerCreditService()
      const calculation = creditService.calculateCreditsRequired(text.length)

      // è·å–ç”¨æˆ·ç§¯åˆ†
      let userCredits = 0
      try {
        const supabase = createSupabaseAdminClient()
        
        const { data: userData, error: userError } = await supabase
          .from('users')
          .select('credits')
          .eq('id', user.id)
          .single()

        if (userError) {
          if (userError.code === 'PGRST116') {
            // ç”¨æˆ·è®°å½•ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°è®°å½•
            const { data: newUser, error: createError } = await supabase
              .from('users')
              .insert([{ 
                id: user.id, 
                email: user.email,
                credits: 3000 
              }])
              .select('credits')
              .single()
            
            if (!createError && newUser) {
              userCredits = newUser.credits
            }
          }
        } else if (userData) {
          userCredits = userData.credits
        }
      } catch (error) {
        console.error('[Queue Translation] ç§¯åˆ†æŸ¥è¯¢å¼‚å¸¸:', error)
      }

      // æ£€æŸ¥ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿ
      if (calculation.credits_required > 0 && userCredits < calculation.credits_required) {
        return NextResponse.json({
          error: `ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${calculation.credits_required} ç§¯åˆ†ï¼Œå½“å‰ä½™é¢ ${userCredits} ç§¯åˆ†`,
          code: 'INSUFFICIENT_CREDITS',
          required: calculation.credits_required,
          available: userCredits
        }, { status: 402 })
      }

      // å…ˆæ‰£é™¤ç§¯åˆ†ï¼ˆåœ¨å¼€å§‹ç¿»è¯‘ä¹‹å‰ï¼‰
      if (calculation.credits_required > 0) {
        try {
          const supabase = createSupabaseAdminClient()
          const { error: deductError } = await supabase
            .from('users')
            .update({ credits: userCredits - calculation.credits_required })
            .eq('id', user.id)

          if (deductError) {
            console.error('[Queue Translation] æ‰£é™¤ç§¯åˆ†å¤±è´¥:', deductError)
            return NextResponse.json({
              error: 'ç§¯åˆ†æ‰£é™¤å¤±è´¥ï¼Œè¯·é‡è¯•',
              code: 'CREDIT_DEDUCTION_FAILED'
            }, { status: 500 })
          }
          
          console.log(`[Queue Translation] ç§¯åˆ†æ‰£é™¤æˆåŠŸ: ${calculation.credits_required} ç§¯åˆ†ï¼Œå‰©ä½™: ${userCredits - calculation.credits_required}`)
        } catch (error) {
          console.error('[Queue Translation] ç§¯åˆ†æ‰£é™¤å¼‚å¸¸:', error)
          return NextResponse.json({
            error: 'ç§¯åˆ†æ‰£é™¤å¤±è´¥ï¼Œè¯·é‡è¯•',
            code: 'CREDIT_DEDUCTION_ERROR'
          }, { status: 500 })
        }
      }
    } else {
      console.log(`[Queue Translation] å…è´¹ç¿»è¯‘: ${text.length}å­—ç¬¦ï¼Œç”¨æˆ·: ${user ? 'å·²ç™»å½•' : 'æœªç™»å½•'}`);
    }

    // ç”Ÿæˆä»»åŠ¡ID
    const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // æ™ºèƒ½åˆ†å—
    const chunks = smartTextChunking(text, CONFIG.MAX_CHUNK_SIZE);
    
    // åˆ›å»ºé˜Ÿåˆ—ä»»åŠ¡
    const job: QueueJob = {
      id: jobId,
      text,
      sourceLanguage,
      targetLanguage,
      chunks,
      status: 'pending',
      progress: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    translationQueue.set(jobId, job);
    
    // ä¿å­˜é˜Ÿåˆ—çŠ¶æ€åˆ°æ–‡ä»¶
    saveQueueToFile();
    
    // å¼‚æ­¥å¼€å§‹å¤„ç† - æ·»åŠ å»¶è¿Ÿç¡®ä¿ä»»åŠ¡çŠ¶æ€æ­£ç¡®åˆå§‹åŒ–
    setTimeout(() => {
      console.log(`[Queue] å‡†å¤‡å¼€å§‹å¤„ç†ä»»åŠ¡: ${jobId}`);
      processTranslationJob(jobId).catch(error => {
        console.error(`[Queue] Job ${jobId} failed:`, error);
        console.error(`[Queue] Error stack:`, error.stack);
        const job = translationQueue.get(jobId);
        if (job) {
          job.status = 'failed';
          job.error = error.message;
          job.updatedAt = new Date();
          translationQueue.set(jobId, job);
          console.log(`[Queue] ä»»åŠ¡ ${jobId} æ ‡è®°ä¸ºå¤±è´¥`);
        } else {
          console.error(`[Queue] æ— æ³•æ‰¾åˆ°å¤±è´¥çš„ä»»åŠ¡: ${jobId}`);
        }
      });
    }, 100); // 100mså»¶è¿Ÿç¡®ä¿ä»»åŠ¡çŠ¶æ€æ­£ç¡®
    
    return NextResponse.json({
      success: true,
      jobId,
      totalChunks: chunks.length,
      estimatedTime: Math.ceil(chunks.length / CONFIG.BATCH_SIZE) * 2, // ä¼°ç®—ç§’æ•°
      message: 'ç¿»è¯‘ä»»åŠ¡å·²åˆ›å»ºï¼Œæ­£åœ¨åå°å¤„ç†'
    });
    
  } catch (error) {
    console.error('[Queue] Create job error:', error);
    return NextResponse.json({
      error: 'åˆ›å»ºç¿»è¯‘ä»»åŠ¡å¤±è´¥',
      code: 'QUEUE_ERROR'
    }, { status: 500 });
  }
}

// æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const jobId = searchParams.get('jobId');
    
    if (!jobId) {
      return NextResponse.json({
        error: 'ç¼ºå°‘ä»»åŠ¡ID',
        code: 'MISSING_JOB_ID'
      }, { status: 400 });
    }
    
    const job = translationQueue.get(jobId);
    
    if (!job) {
      console.log(`[Queue] ä»»åŠ¡ä¸å­˜åœ¨: ${jobId}, å½“å‰é˜Ÿåˆ—ä¸­æœ‰ ${translationQueue.size} ä¸ªä»»åŠ¡`);
      
      return NextResponse.json({
        success: false,
        error: 'ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ',
        code: 'JOB_NOT_FOUND',
        suggestion: 'ä»»åŠ¡å¯èƒ½å·²å®Œæˆå¹¶è¢«æ¸…ç†ï¼Œæˆ–è€…æœåŠ¡å·²é‡å¯ã€‚è¯·é‡æ–°æäº¤ç¿»è¯‘è¯·æ±‚ã€‚'
      }, { status: 404 });
    }
    
    // æ·»åŠ è°ƒè¯•æ—¥å¿—
    console.log(`[Queue] æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€: ${jobId}`, {
      status: job.status,
      progress: job.progress,
      hasResult: !!job.result,
      resultLength: job.result?.length || 0
    });
    
    return NextResponse.json({
      success: true,
      job: {
        id: job.id,
        status: job.status,
        progress: job.progress,
        result: job.result,
        error: job.error,
        totalChunks: job.chunks.length,
        createdAt: job.createdAt,
        updatedAt: job.updatedAt
      }
    });
    
  } catch (error) {
    console.error('[Queue] Get job status error:', error);
    return NextResponse.json({
      error: 'æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€å¤±è´¥',
      code: 'QUERY_ERROR'
    }, { status: 500 });
  }
}

// å¤„ç†ç¿»è¯‘ä»»åŠ¡
async function processTranslationJob(jobId: string) {
  console.log(`[Queue] processTranslationJob å¼€å§‹æ‰§è¡Œ: ${jobId}`);
  
  const job = translationQueue.get(jobId);
  if (!job) {
    console.log(`[Queue] Job ${jobId} not found in queue`);
    return;
  }
  
  console.log(`[Queue] æ‰¾åˆ°ä»»åŠ¡ï¼Œå½“å‰çŠ¶æ€: ${job.status}`);
  
  console.log(`[Queue] å¼€å§‹å¤„ç†ä»»åŠ¡ ${jobId}:`, {
    textLength: job.text.length,
    chunksCount: job.chunks.length,
    sourceLanguage: job.sourceLanguage,
    targetLanguage: job.targetLanguage
  });
  
  try {
    console.log(`[Queue] è®¾ç½®ä»»åŠ¡çŠ¶æ€ä¸ºprocessing: ${jobId}`);
    job.status = 'processing';
    job.progress = 5; // è®¾ç½®åˆå§‹è¿›åº¦5%ï¼Œè¡¨ç¤ºå¼€å§‹å¤„ç†
    job.updatedAt = new Date();
    translationQueue.set(jobId, job); // ç«‹å³ä¿å­˜çŠ¶æ€æ›´æ–°
    saveQueueToFile(); // ä¿å­˜åˆ°å¤‡ä»½æ–‡ä»¶
    console.log(`[Queue] ä»»åŠ¡çŠ¶æ€å·²æ›´æ–°å¹¶ä¿å­˜: ${jobId}`);
    
    const translatedChunks: string[] = [];
    const totalChunks = job.chunks.length;
    
    // åˆ†æ‰¹å¤„ç†å—
    for (let i = 0; i < totalChunks; i += CONFIG.BATCH_SIZE) {
      const batch = job.chunks.slice(i, i + CONFIG.BATCH_SIZE);
      console.log(`[Queue] å¤„ç†æ‰¹æ¬¡ ${Math.floor(i/CONFIG.BATCH_SIZE) + 1}/${Math.ceil(totalChunks/CONFIG.BATCH_SIZE)}, å—æ•°: ${batch.length}`);
      
      // åœ¨æ‰¹æ¬¡å¼€å§‹æ—¶æ›´æ–°è¿›åº¦
      const startProgress = Math.round((i / totalChunks) * 90) + 10; // 10-100%èŒƒå›´
      job.progress = startProgress;
      job.updatedAt = new Date();
      translationQueue.set(jobId, job);
      console.log(`[Queue] æ‰¹æ¬¡å¼€å§‹è¿›åº¦: ${job.progress}%`);
      
      // å¹¶è¡Œå¤„ç†å½“å‰æ‰¹æ¬¡
      const batchPromises = batch.map((chunk, index) => {
        console.log(`[Queue] ç¿»è¯‘å— ${i + index + 1}/${totalChunks}: ${chunk.substring(0, 50)}...`);
        return translateChunkWithRetry(chunk, job.sourceLanguage, job.targetLanguage);
      });
      
      const batchResults = await Promise.all(batchPromises);
      console.log(`[Queue] æ‰¹æ¬¡ç»“æœ:`, batchResults.map(r => ({ success: r.success, length: r.translatedText?.length || 0 })));
      
      // æ£€æŸ¥æ‰¹æ¬¡ç»“æœ - æ‰¹æ¬¡çº§é‡è¯•æœºåˆ¶
      let successCount = 0;
      let failedChunks = [];
      
      for (let j = 0; j < batchResults.length; j++) {
        const result = batchResults[j];
        const chunkIndex = i + j + 1;
        
        if (result.success) {
          successCount++;
          console.log(`[Queue] å— ${chunkIndex}/${totalChunks} ç¿»è¯‘æˆåŠŸ`);
        } else {
          failedChunks.push({ 
            index: chunkIndex, 
            error: result.error,
            text: batch[j]
          });
          console.error(`[Queue] å— ${chunkIndex}/${totalChunks} ç¿»è¯‘å¤±è´¥: ${result.error}`);
        }
      }
      
      // æ‰¹æ¬¡çº§é‡è¯•é€»è¾‘
      if (failedChunks.length > 0) {
        const batchIndex = Math.floor(i / CONFIG.BATCH_SIZE) + 1;
        const batchRetryKey = `batch_${batchIndex}_retry`;
        const batchRetryCount = job[batchRetryKey] || 0;
        const maxBatchRetries = 2; // æ¯ä¸ªæ‰¹æ¬¡æœ€å¤šé‡è¯•2æ¬¡
        
        if (batchRetryCount < maxBatchRetries) {
          console.log(`[Queue] æ‰¹æ¬¡ ${batchIndex} æœ‰ ${failedChunks.length} ä¸ªå—å¤±è´¥ï¼Œå‡†å¤‡é‡è¯• (ç¬¬${batchRetryCount + 1}æ¬¡)`);
          
          // è®°å½•æ‰¹æ¬¡é‡è¯•æ¬¡æ•°
          job[batchRetryKey] = batchRetryCount + 1;
          job.updatedAt = new Date();
          translationQueue.set(jobId, job);
          
          // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•æ‰¹æ¬¡
          console.log(`[Queue] ç­‰å¾… 3 ç§’åé‡è¯•æ‰¹æ¬¡ ${batchIndex}...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
          
          // é‡æ–°å¤„ç†å½“å‰æ‰¹æ¬¡ - å›é€€å¾ªç¯ç´¢å¼•
          i -= CONFIG.BATCH_SIZE;
          continue;
        } else {
          console.error(`[Queue] æ‰¹æ¬¡ ${batchIndex} é‡è¯• ${maxBatchRetries} æ¬¡åä»æœ‰å¤±è´¥ï¼Œè·³è¿‡è¯¥æ‰¹æ¬¡`);
          
          // å¯¹äºæœ€ç»ˆå¤±è´¥çš„å—ï¼Œè®°å½•é”™è¯¯ä½†ç»§ç»­å¤„ç†
          for (let j = 0; j < batchResults.length; j++) {
            const result = batchResults[j];
            if (result.success) {
              translatedChunks.push(result.translatedText!);
            } else {
              // æœ€ç»ˆå¤±è´¥çš„å—ï¼Œæ·»åŠ é”™è¯¯æ ‡è®°
              translatedChunks.push(`[å—${i + j + 1}ç¿»è¯‘å¤±è´¥: ${result.error}]`);
            }
          }
        }
      } else {
        // æ‰¹æ¬¡å®Œå…¨æˆåŠŸï¼Œæ·»åŠ æ‰€æœ‰ç¿»è¯‘ç»“æœ
        for (const result of batchResults) {
          translatedChunks.push(result.translatedText!);
        }
        
        console.log(`[Queue] æ‰¹æ¬¡ ${Math.floor(i / CONFIG.BATCH_SIZE) + 1} å®Œå…¨æˆåŠŸ`);
      }
      if (successCount === 0) {
        console.warn(`[Queue] è­¦å‘Š: æ‰¹æ¬¡ ${Math.floor(i / CONFIG.BATCH_SIZE) + 1} å…¨éƒ¨å¤±è´¥ï¼Œä½†ç»§ç»­å¤„ç†åç»­æ‰¹æ¬¡`);
      }
      
      // æ‰¹æ¬¡å®Œæˆåæ›´æ–°è¿›åº¦å¹¶ç«‹å³ä¿å­˜
      const completedChunks = i + batch.length;
      job.progress = Math.round((completedChunks / totalChunks) * 90) + 10; // 10-100%èŒƒå›´
      job.updatedAt = new Date();
      translationQueue.set(jobId, job); // ç«‹å³ä¿å­˜è¿›åº¦æ›´æ–°
      saveQueueToFile(); // ç¡®ä¿æŒä¹…åŒ–
      
      console.log(`[Queue] è¿›åº¦æ›´æ–°: ${job.progress}% (${completedChunks}/${totalChunks})`);
      
      // æ‰¹æ¬¡é—´å»¶è¿Ÿ
      if (i + CONFIG.BATCH_SIZE < totalChunks) {
        console.log(`[Queue] æ‰¹æ¬¡é—´å»¶è¿Ÿ ${CONFIG.BATCH_DELAY}ms...`);
        await new Promise(resolve => setTimeout(resolve, CONFIG.BATCH_DELAY));
      }
    }
    
    // åˆå¹¶ç»“æœ
    job.result = translatedChunks.join(' ');
    job.status = 'completed';
    job.progress = 100;
    job.updatedAt = new Date();
    
    // é‡è¦ï¼šä¿å­˜å®ŒæˆçŠ¶æ€åˆ°é˜Ÿåˆ—
    translationQueue.set(jobId, job);
    saveQueueToFile(); // ä¿å­˜åˆ°å¤‡ä»½æ–‡ä»¶
    
    console.log(`[Queue] Job ${jobId} completed successfully`, {
      totalChunks: translatedChunks.length,
      resultLength: job.result.length,
      resultPreview: job.result.substring(0, 100) + '...'
    });
    
  } catch (error) {
    job.status = 'failed';
    job.error = error instanceof Error ? error.message : 'ç¿»è¯‘å¤±è´¥';
    job.updatedAt = new Date();
    
    // é‡è¦ï¼šä¿å­˜å¤±è´¥çŠ¶æ€åˆ°é˜Ÿåˆ—
    translationQueue.set(jobId, job);
    saveQueueToFile(); // ä¿å­˜åˆ°å¤‡ä»½æ–‡ä»¶
    
    console.error(`[Queue] Job ${jobId} failed:`, error);
  }
}

// å¸¦é‡è¯•çš„å—ç¿»è¯‘
async function translateChunkWithRetry(
  text: string, 
  sourceLanguage: string, 
  targetLanguage: string, 
  retryCount: number = 0
): Promise<{success: boolean, translatedText?: string, error?: string}> {
  
  try {
    const nllbServiceUrl = 'https://wane0528-my-nllb-api.hf.space/api/v4/translator';
    
    // æ˜ å°„è¯­è¨€ä»£ç 
    const nllbSourceLang = mapToNLLBLanguageCode(sourceLanguage);
    const nllbTargetLang = mapToNLLBLanguageCode(targetLanguage);
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), CONFIG.REQUEST_TIMEOUT);
    
    const response = await fetch(nllbServiceUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({
        text,
        source: nllbSourceLang,
        target: nllbTargetLang,
        max_length: 1000
      }),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`ç¿»è¯‘æœåŠ¡é”™è¯¯: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.error) {
      throw new Error(result.error);
    }

    return {
      success: true,
      translatedText: result.result || result.translated_text || result.translation || text
    };

  } catch (error: any) {
    if (retryCount < CONFIG.MAX_RETRIES) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      return translateChunkWithRetry(text, sourceLanguage, targetLanguage, retryCount + 1);
    }
    
    return {
      success: false,
      error: error.message || 'ç¿»è¯‘å¤±è´¥'
    };
  }
}

// æ™ºèƒ½åˆ†å—å‡½æ•°
/**
 * ç»Ÿä¸€çš„æ™ºèƒ½æ–‡æœ¬åˆ†å—å‡½æ•°
 * ä¼˜å…ˆçº§: æ®µè½è¾¹ç•Œ > å¥å­è¾¹ç•Œ > é€—å·è¾¹ç•Œ > è¯æ±‡è¾¹ç•Œ
 */
function smartTextChunking(text, maxChunkSize = 600) {
  if (text.length <= maxChunkSize) {
    return [text];
  }

  console.log(`ğŸ“ æ™ºèƒ½åˆ†å—: ${text.length}å­—ç¬¦ -> ${maxChunkSize}å­—ç¬¦/å—`);
  
  const chunks = [];
  
  // ç­–ç•¥1: æŒ‰æ®µè½åˆ†å‰²ï¼ˆåŒæ¢è¡Œï¼‰
  const paragraphs = text.split(/\n\s*\n/);
  
  for (const paragraph of paragraphs) {
    if (paragraph.trim().length === 0) continue;
    
    if (paragraph.length <= maxChunkSize) {
      chunks.push(paragraph.trim());
    } else {
      // ç­–ç•¥2: æŒ‰å¥å­åˆ†å‰²
      const sentences = paragraph.split(/[.!?ã€‚ï¼ï¼Ÿ]\s+/);
      let currentChunk = '';
      
      for (let i = 0; i < sentences.length; i++) {
        const sentence = sentences[i].trim();
        if (!sentence) continue;
        
        const potentialChunk = currentChunk + (currentChunk ? '. ' : '') + sentence;
        
        if (potentialChunk.length <= maxChunkSize) {
          currentChunk = potentialChunk;
        } else {
          // ä¿å­˜å½“å‰å—
          if (currentChunk) {
            chunks.push(currentChunk + (currentChunk.endsWith('.') ? '' : '.'));
          }
          
          // å¤„ç†è¶…é•¿å¥å­
          if (sentence.length > maxChunkSize) {
            const subChunks = forceChunkBySentence(sentence, maxChunkSize);
            chunks.push(...subChunks);
            currentChunk = '';
          } else {
            currentChunk = sentence;
          }
        }
      }
      
      // æ·»åŠ æœ€åä¸€ä¸ªå—
      if (currentChunk) {
        chunks.push(currentChunk + (currentChunk.endsWith('.') ? '' : '.'));
      }
    }
  }
  
  const finalChunks = chunks.filter(chunk => chunk.trim().length > 0);
  console.log(`âœ… åˆ†å—å®Œæˆ: ${finalChunks.length}ä¸ªå—`);
  
  return finalChunks;
}

/**
 * å¼ºåˆ¶åˆ†å—å¤„ç†è¶…é•¿å¥å­
 */
function forceChunkBySentence(sentence, maxSize) {
  const chunks = [];
  
  // ç­–ç•¥3: æŒ‰é€—å·åˆ†å‰²
  const parts = sentence.split(/,\s+/);
  let currentChunk = '';
  
  for (const part of parts) {
    const potentialChunk = currentChunk + (currentChunk ? ', ' : '') + part;
    
    if (potentialChunk.length <= maxSize) {
      currentChunk = potentialChunk;
    } else {
      if (currentChunk) {
        chunks.push(currentChunk);
      }
      
      // ç­–ç•¥4: æŒ‰ç©ºæ ¼åˆ†å‰²ï¼ˆè¯æ±‡è¾¹ç•Œï¼‰
      if (part.length > maxSize) {
        const words = part.split(' ');
        let wordChunk = '';
        
        for (const word of words) {
          const potentialWordChunk = wordChunk + (wordChunk ? ' ' : '') + word;
          
          if (potentialWordChunk.length <= maxSize) {
            wordChunk = potentialWordChunk;
          } else {
            if (wordChunk) {
              chunks.push(wordChunk);
            }
            wordChunk = word.length > maxSize ? word.substring(0, maxSize) : word;
          }
        }
        
        if (wordChunk) {
          chunks.push(wordChunk);
        }
        currentChunk = '';
      } else {
        currentChunk = part;
      }
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  
  return chunks;
}

// è¯­è¨€ä»£ç æ˜ å°„
function mapToNLLBLanguageCode(language: string): string {
  const languageMap: Record<string, string> = {
    'am': 'amh_Ethi', 'ar': 'arb_Arab', 'en': 'eng_Latn', 'es': 'spa_Latn',
    'fr': 'fra_Latn', 'ha': 'hau_Latn', 'hi': 'hin_Deva', 'ht': 'hat_Latn',
    'ig': 'ibo_Latn', 'km': 'khm_Khmr', 'ky': 'kir_Cyrl', 'lo': 'lao_Laoo',
    'mg': 'plt_Latn', 'mn': 'khk_Cyrl', 'my': 'mya_Mymr', 'ne': 'npi_Deva',
    'ps': 'pbt_Arab', 'pt': 'por_Latn', 'sd': 'snd_Arab', 'si': 'sin_Sinh',
    'sw': 'swh_Latn', 'te': 'tel_Telu', 'tg': 'tgk_Cyrl', 'xh': 'xho_Latn',
    'yo': 'yor_Latn', 'zh': 'zho_Hans', 'zu': 'zul_Latn'
  };
  
  return languageMap[language] || language;
}

// å¤„ç†ä¸‹ä¸€ä¸ªpendingä»»åŠ¡
async function processNextPendingJob() {
  try {
    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªpendingçŠ¶æ€çš„ä»»åŠ¡
    let pendingJob = null;
    let pendingJobId = null;
    
    for (const [jobId, job] of translationQueue.entries()) {
      if (job.status === 'pending') {
        pendingJob = job;
        pendingJobId = jobId;
        break;
      }
    }
    
    if (!pendingJob) {
      console.log('[Queue] æ²¡æœ‰pendingä»»åŠ¡éœ€è¦å¤„ç†');
      return;
    }
    
    console.log(`[Queue] å‡†å¤‡å¼€å§‹å¤„ç†ä»»åŠ¡: ${pendingJobId}`);
    console.log(`[Queue] processTranslationJob å¼€å§‹æ‰§è¡Œ: ${pendingJobId}`);
    
    // è®¾ç½®ä»»åŠ¡çŠ¶æ€ä¸ºprocessing
    pendingJob.status = 'processing';
    pendingJob.updatedAt = new Date();
    translationQueue.set(pendingJobId, pendingJob);
    
    console.log(`[Queue] è®¾ç½®ä»»åŠ¡çŠ¶æ€ä¸ºprocessing: ${pendingJobId}`);
    console.log(`[Queue] ä»»åŠ¡çŠ¶æ€å·²æ›´æ–°å¹¶ä¿å­˜: ${pendingJobId}`);
    
    // å¼€å§‹å¤„ç†ä»»åŠ¡
    console.log(`[Queue] å¼€å§‹å¤„ç†ä»»åŠ¡ ${pendingJobId}: {`);
    console.log(`  æ–‡æœ¬é•¿åº¦: ${pendingJob.text.length}`);
    console.log(`  åˆ†å—æ•°é‡: ${pendingJob.chunks.length}`);
    console.log(`  æºè¯­è¨€: ${pendingJob.sourceLanguage}`);
    console.log(`  ç›®æ ‡è¯­è¨€: ${pendingJob.targetLanguage}`);
    console.log(`}`);
    
    // å¤„ç†æ‰€æœ‰åˆ†å—
    const results = [];
    let completedChunks = 0;
    
    for (let i = 0; i < pendingJob.chunks.length; i++) {
      const chunk = pendingJob.chunks[i];
      
      try {
        console.log(`[Queue] å¤„ç†åˆ†å— ${i + 1}/${pendingJob.chunks.length}: ${chunk.substring(0, 50)}...`);
        
        const result = await translateChunkWithRetry(
          chunk,
          pendingJob.sourceLanguage,
          pendingJob.targetLanguage
        );
        
        if (result.success) {
          results.push(result.translatedText);
          completedChunks++;
          
          // æ›´æ–°è¿›åº¦
          const progress = Math.round((completedChunks / pendingJob.chunks.length) * 100);
          pendingJob.progress = progress;
          pendingJob.updatedAt = new Date();
          translationQueue.set(pendingJobId, pendingJob);
          
          console.log(`[Queue] åˆ†å— ${i + 1} ç¿»è¯‘æˆåŠŸï¼Œè¿›åº¦: ${progress}%`);
        } else {
          throw new Error(result.error || 'ç¿»è¯‘å¤±è´¥');
        }
        
        // åˆ†å—é—´å»¶è¿Ÿ
        if (i < pendingJob.chunks.length - 1) {
          await new Promise(resolve => setTimeout(resolve, CONFIG.CHUNK_DELAY));
        }
        
      } catch (error) {
        console.error(`[Queue] åˆ†å— ${i + 1} ç¿»è¯‘å¤±è´¥:`, error);
        
        // ä»»åŠ¡å¤±è´¥
        pendingJob.status = 'failed';
        pendingJob.error = error.message;
        pendingJob.updatedAt = new Date();
        translationQueue.set(pendingJobId, pendingJob);
        
        // ä¿å­˜çŠ¶æ€å¹¶ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡
        saveQueueToFile();
        setTimeout(() => processNextPendingJob(), 1000);
        return;
      }
    }
    
    // ä»»åŠ¡å®Œæˆ
    const finalResult = results.join(' ');
    pendingJob.status = 'completed';
    pendingJob.progress = 100;
    pendingJob.result = finalResult;
    pendingJob.updatedAt = new Date();
    translationQueue.set(pendingJobId, pendingJob);
    
    console.log(`[Queue] ä»»åŠ¡ ${pendingJobId} å®Œæˆï¼Œç»“æœé•¿åº¦: ${finalResult.length}`);
    
    // ä¿å­˜çŠ¶æ€
    saveQueueToFile();
    
    // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡
    setTimeout(() => processNextPendingJob(), 1000);
    
  } catch (error) {
    console.error('[Queue] å¤„ç†ä»»åŠ¡æ—¶å‘ç”Ÿé”™è¯¯:', error);
    // 1ç§’åé‡è¯•
    setTimeout(() => processNextPendingJob(), 1000);
  }
}
